@page "/merge"
@using System.IO
@using System.Text
@using CycloneDX.Models
@using CycloneDX.Xml
@using CycloneDX.Json

@inject IJSRuntime _jsRuntime;

<h1>Merge</h1>

<p>Merge multiple BOMs</p>

<form>
    <label>
        Input Files
        <InputFile multiple id="inputFiles" OnChange="@LoadInputFiles"></InputFile>
    </label>
    
    <label>
        Input Format
        <select id="inputFormat" @bind="_inputFormat">
            <option value="autodetect" selected="selected">Autodetect</option>
            <option value="json">JSON</option>
            <option value="xml">XML</option>
        </select>
    </label>
    
    <label>
        Output Format
        <select id="outputFormat" @bind="_outputFormat">
            <option value="json" selected="selected">JSON</option>
            <option value="xml">XML</option>
        </select>
    </label>
    
    <label>
        Version
        <select id="outputVersion" @bind="_outputVersion">
            <option value="v1.3" selected="selected">v1.3</option>
            <option value="v1.2">v1.2</option>
            <option value="v1.1">v1.1</option>
            <option value="v1.0">v1.0</option>
        </select>
    </label>
    
    <button id="merge" type="button" @onclick="@MergeBOM" hidden="@(_inputFileContents == null)">Merge & Download</button>
</form>

@code {
    private List<string> _inputFileContents;
    private List<string> _userInputFilenames;
    private string _inputFormat = "autodetect";
    private string _outputFormat = "json";
    private string _outputVersion = "v1.3";

    private async Task Alert(string message)
    {
        await _jsRuntime.InvokeVoidAsync("alert", message);
    }

    private async Task LoadInputFiles(InputFileChangeEventArgs e)
    {
        if (e.FileCount > 0)
        {
            _inputFileContents = new List<string>();
            _userInputFilenames = new List<string>();
            foreach (var file in e.GetMultipleFiles())
            {
                string contents;
                using (var sr = new StreamReader(file.OpenReadStream()))
                {
                    contents = await sr.ReadToEndAsync();
                }
                _inputFileContents.Add(contents);
                _userInputFilenames.Add(file.Name);
            }
        }
        else
        {
            _inputFileContents = null;
            _userInputFilenames = null;
        }
    }

    private async Task MergeBOM()
    {
        Models.v1_3.Bom mergedBom = null;
        for (var i = 0; i < _inputFileContents.Count; i++)
        {
            var fileContents = _inputFileContents[i];
            var filename = _userInputFilenames[i];
            Models.v1_3.Bom currentBom = null;
            
            if (_inputFormat == "json" || _inputFormat == "autodetect" && filename.EndsWith(".json"))
            {
                try
                {
                    currentBom = Json.Deserializer.Deserialize(fileContents);
                }
                catch (Exception e)
                {
                    await Alert("Error deserializing BOM: " + e.Message);
                    return;
                }
            }
            else if (_inputFormat == "xml" || _inputFormat == "autodetect" && filename.EndsWith(".xml"))
            {
                try
                {
                    currentBom = Xml.Deserializer.Deserialize(fileContents);
                }
                catch (Exception e)
                {
                    await Alert("Error deserializing BOM: " + e.Message);
                    return;
                }
            }
            else
            {
                await Alert("Unable to auto-detect input format. Please specify the format.");
                return;
            }

            if (mergedBom == null)
            {
                mergedBom = currentBom;
            }
            else
            {
                mergedBom = CycloneDXUtils.Merge(mergedBom, currentBom);
            }
        }

        string output;
        
        if (_outputFormat == "json")
        {
            if (_outputVersion == "v1.2")
            {
                var bom12 = new Models.v1_2.Bom(mergedBom);
                output = Json.Serializer.Serialize(bom12);
            }
            else if (_outputVersion == "v1.1" || _outputVersion == "v1.0")
            {
                await Alert("Invalid version specified for JSON output. JSON output is only supported for versions >= 1.2");
                return;
            }
            else
            {
                output = Json.Serializer.Serialize(mergedBom);
            }
        }
        else
        {
            if (_outputVersion == "v1.2")
            {
                var bom12 = new Models.v1_2.Bom(mergedBom);
                output = Xml.Serializer.Serialize(bom12);
            }
            else if (_outputVersion == "v1.1")
            {
                var bom12 = new Models.v1_2.Bom(mergedBom);
                var bom11 = new Models.v1_1.Bom(bom12);
                output = Xml.Serializer.Serialize(bom11);
            }
            else if (_outputVersion == "v1.0")
            {
                var bom12 = new Models.v1_2.Bom(mergedBom);
                var bom11 = new Models.v1_1.Bom(bom12);
                var bom10 = new Models.v1_0.Bom(bom11);
                output = Xml.Serializer.Serialize(bom10);
            }
            else
            {
                output = Xml.Serializer.Serialize(mergedBom);
            }
        }
        
        var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(output);
        var outputBom64 = System.Convert.ToBase64String(plainTextBytes);
        
        await _jsRuntime.InvokeVoidAsync("cdxFileDownload", "merged-bom." + _outputFormat, outputBom64);
    }
}
